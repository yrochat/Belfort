write.csv(aaa[,-(1:2)], file="aaa.csv")
get.edgelist(graph.adjacency(aaa))
graph.adjacency(aaa)
?graph.adjacency
bipartite.mapping(aaa)
graph.bipartite(aaa)
graph.bipartite(edges=aaa)
?graph.bipartite
dim(aaa)
?graph.bipartite
?graph.adjacency
graph.adjacency(aa)
graph.adjacency(aaa)
setwd("~/Documents/Belfort/Exemple")
rm(list=ls())#
#
setwd("~/Documents/Belfort/Exemple")
library(igraph)
mat <- read.csv("assomoir-adj.csv")
mat
rm(list=ls())#
#
setwd("~/Dropbox/DHLab perso/2014/20141103 DH2015 [abstract]")#
#
library(igraph)#
library(plyr)#
library(RColorBrewer)#
library(xtable)#
#
options(stringsAsFactors = FALSE)#
#
load(".RData")
write.csv(aaa[,-(1:2)], file="aaa.csv")
write.csv(table(res[which(res$livre == RM[7]),c(1,3)])[,-(1:2)], file="aaa.csv")
mat <- read.csv("assomoir-adj.csv")
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.csv("assomoir-adj.csv")
head(mat)
?read.csv
mat <- read.csv("assomoir-adj.csv", header = TRUE)
head(mat)
mat[2,2]
class(mat[2,2])
class(mat[1,2])
mat[1,2]
colnames(mat)
mat <- read.csv("assomoir-adj.csv", header = TRUE, check.names = FALSE)
colnames(mat)
class(mat)
?read.csv
rownames(mat)
?graph.adjacency
??bipartite
graph.incidency
graph.incidence
graph.incidence(mat)
g <- graph.incidence(mat)
str(mat)
g
V(g)
?read.csv?read.table
?read.table
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE)
colnames(mat)
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")
colnames(mat)
rownames(mat)
head(mat)
?read.talbe
?read.table
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", check.names = FALSE, sep=",")
mat[1,1]
mat[1,2]
mat[2,1]
mat[1:5,1:5]
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")
mat[1:5,1:5]
rownames(mat) <- mat[,1]
mat <- mat[,-1]
mat[1:5,1:5]
g <- graph.incidence(mat)
V(g)
g <- graph.incidence(t(mat))
V(g)
g <- graph.incidence(mat)
bipartite.mapping(g)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]
mat[1:5,1:5]
colnames(mat)
mat2 <- mat
colnames(mat)
paste0(colnames(mat), colnames(mat), collapse="")
paste(colnames(mat), colnames(mat), collapse="")
paste(colnames(mat), colnames(mat), sep="")
paste(as.numeric(colnames(mat)), colnames(mat), sep="")
paste(as.numeric(colnames(mat))-1, colnames(mat), sep="")
colnames(mat2) <- paste(colnames(mat), as.numeric(colnames(mat))+1, sep="")
colnames(mat2)
mat0 <- cbind(mat,mat2)
colnames(mat0)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
mat2 <- mat#
#
colnames(mat) <- paste(as.numeric(colnames(mat))-1, colnames(mat), sep="")#
colnames(mat2) <- paste(colnames(mat), as.numeric(colnames(mat))+1, sep="")#
#
mat0 <- cbind(mat,mat2)
colnames(mat0)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
mat1 <- mat2 <- mat#
#
colnames(mat1) <- paste(as.numeric(colnames(mat))-1, colnames(mat), sep="")#
colnames(mat2) <- paste(colnames(mat), as.numeric(colnames(mat))+1, sep="")#
#
mat0 <- cbind(mat1, mat2)
head(mat0)
mat0[1:5,1:5]
g <- graph.incidence(mat)
g <- graph.incidence(mat, multiple = TRUE)
g
?graph.incidence
graph.bipartite(g)
bipartite.mapping(g)
bipartite.mapping(g)$type
graph.bipartite(g, types=bipartite.mapping(g)$type)
g <- graph.incidence(mat, multiple = TRUE)
g
rownames(mat0)
g <- graph.incidence(mat0, multiple = TRUE)
g
length(rownames(mat0))
length(colnames(mat0))
length(unique(colnames(mat0)))
?graph.incidence
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
mat1 <- mat2 <- mat#
#
colnames(mat1) <- paste(as.numeric(colnames(mat))-1, colnames(mat), sep="")#
colnames(mat2) <- paste(colnames(mat), as.numeric(colnames(mat))+1, sep="")#
#
mat0 <- cbind(mat1, mat2)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)
tab
head(tab)
tab2 <- tab1 <- get.edgelist(g)
tab2 <- tab1 <- tab <- get.edgelist(g)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)#
#
colnames(tab) <- c("Nom", "Page")#
#
tab2 <- tab1 <- tab#
#
tab1$page <- paste(as.numeric(colnames(tab$page))-1, colnames(tab$page), sep="")
tab$page
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)#
#
colnames(tab) <- c("Nom", "Page")#
#
tab2 <- tab1 <- tab#
#
tab1$Page <- paste(as.numeric(colnames(tab$Page))-1, colnames(tab$Page), sep="")
tab1
str(tab1)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)
colnames(tab)
colnames(tab) <- c("Nom", "Page")
str(tab)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)
class(tab)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)#
#
tab2 <- tab1 <- tab#
#
tab1[,2] <- paste(as.numeric(colnames(tab[,2]))-1, colnames(tab[,2]), sep="")
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")
head(tab1)
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")
tab0 <- rbind(tab1, tab2)
str(tab0)
graph.edgelist(tab0, directed = FALSE)
g <- graph.edgelist(tab0, directed = FALSE)
V(g)
(V(g)$name)unique
unique(V(g)$name)
is.duplicate(V(g)$name)
is.duplicated(V(g)$name)
duplicated(V(g)$name)
is.simple(g)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)#
#
tab2 <- tab1 <- tab#
#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
tab0 <- rbind(tab1, tab2)#
#
g <- graph.edgelist(tab0, directed = FALSE)
g0 <- graph.bipartite(g, types=bipartite.mapping(g)$type)
bipartite.mapping(g)$type
bipartite.mapping(g)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
rownames(mat) <- mat[,1]#
mat <- mat[,-1]#
#
g <- graph.incidence(mat, multiple = TRUE)#
#
tab <- get.edgelist(g)#
#
tab2 <- tab1 <- tab#
#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
tab0 <- rbind(tab1, tab2)#
#
g <- graph.edgelist(tab0, directed = FALSE)
g0 <- graph.bipartite(g, types=bipartite.mapping(g)$type)
graph.bipartite(g, types=bipartite.mapping(g)$type)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe à partir de cette matrice d'incidence#
g <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)
??duplicate
duplicated(tab0)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe à partir de cette matrice d'incidence#
g <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]
g <- graph.edgelist(tab0, directed = FALSE)
g0 <- graph.bipartite(g, types=bipartite.mapping(g)$type)
g <- graph.edgelist(tab0, directed = FALSE)
is.simple(g)
??bipartite
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g <- graph.edgelist(tab0, directed = FALSE)
bipartite.mapping(g)$type
g0 <- bipartite.projection(g, types=bipartite.mapping(g)$type, multiplicity = TRUE)
g0 <- bipartite.projection(g, type=bipartite.mapping(g)$type, multiplicity = TRUE)
bipartite.mapping(g)
g0 <- bipartite.projection(g, multiplicity = TRUE)
g$types <- bipartite.mapping(g)$type
g0 <- bipartite.projection(g, multiplicity = TRUE)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g <- graph.edgelist(tab0, directed = FALSE)
V(g)$types <- bipartite.mapping(g)$type
g0 <- bipartite.projection(g, multiplicity = TRUE)
bipartite.mapping(g)$type
V(g)$types <- bipartite.mapping(g)$type
g
g0 <- bipartite.projection(g)
g0 <- bipartite.projection(g, types = bipartite.mapping(g)$type)
g0 <- bipartite.projection(g, types = V(g)$types)
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g <- graph.edgelist(tab0, directed = FALSE)
V(g)$type <- bipartite.mapping(g)$type
g0 <- bipartite.projection(g)
?bipartite.projection
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g)$type <- bipartite.mapping(g)$type#
#
# Et voilà le produit final !#
g0 <- bipartite.projection(g)
g0
rm(list=ls())#
#
library(igraph)#
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Et voilà le produit final !#
g <- bipartite.projection(g0)$proj1
g
is.simple(g)
E(g)$weight
?delete.edges
E(g)
E(g)$weight >= 3
E(g)$weight < 3
E(g)[E(g)$weight < 3]
g <- g - E(g)[E(g)$weight < 3]
g
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe#
plot(g)#
#
# Et on ferme le tunnel#
dev.off()
warnings()
g
degree(g)
sort(table(degree(g)))
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = substr(V(g)$name, 1, 10),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = substr(V(g)$name, 1, 8),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6)), "\\.", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), "\\.", sep="")),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), "\\.", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), "\.", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
clusters(G)
clusters(g)
??subgraph
clusters(g)$membership
clusters(g)
which.max(clusters(g)$csize)
clusters(g)$membership
which(clusters(g)$membership == which.max(clusters(g)$csize))
induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^2.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g)),#
		vertex.color = "white",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
?layout
log2(degree(g))
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
E(g)$weight
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		edge.width = log2(E(g)$width)#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		edge.width = log2(E(g)$width),#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
log2(E(g)$width)
E(g)$weight
log2(E(g)$weight)
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		edge.width = sqrt(log2(E(g)$weight)),#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "darkorange",#
		edge.width = sqrt(log2(E(g)$weight)),#
		edge.color = "pink",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 10, width = 10)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "darkorange",#
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
?plot.igraph
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "darkorange",#
		vertex.label.dist = 1,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "darkorange",#
		vertex.label.dist = .1,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = .25,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
??map
??range
log2(degree(g)-1)
log2(degree(g))-1
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-1)/10,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.8)/10,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.8)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.8)/100,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.8)/25,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.8)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g)))/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.6)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.4)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.2)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
# Pour plus de renseignements, taper dans la console la commande suivant :#
# ?igraph.plotting#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.2)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()#
#
# Le résultat est assez illisible, et devra être amélioré au cas par cas#
# par exemple avec tkplot pour choisir un meilleur emplacement pour les noeuds#
# ou alors en changeant tailles, couleurs, etc.#
#
# À étudier : les différentes possibilités d'export en D3…
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
# Pour plus de renseignements, taper dans la console la commande suivant :#
# ?igraph.plotting#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.2)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()#
#
# Le résultat est assez illisible, et devra être amélioré au cas par cas#
# par exemple avec tkplot pour choisir un meilleur emplacement pour les noeuds#
# ou alors en changeant tailles, couleurs, etc.#
#
# À étudier : les différentes possibilités d'export en D3…
rm(list=ls())#
#
# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux#
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :#
# install.packages("igraph")#
library(igraph) #
#
setwd("~/Documents/Belfort/Exemple")#
#
# On importe le csv sous forme de matrice d'incidence#
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")#
#
# On donne comme noms de ligne les noms de la première colonne#
rownames(mat) <- mat[,1]#
#
# Puis on la supprime#
mat <- mat[,-1]#
# Maintenant la matrice n'est plus composée que de 0 et de 1#
#
# On crée un graphe biparti à partir de cette matrice d'incidence#
g0 <- graph.incidence(mat, multiple = TRUE)#
#
# On extrait la liste des arêtes, et on la copie deux fois#
tab <- get.edgelist(g0)#
tab2 <- tab1 <- tab#
#
# Ici, chaque page n se transforme en couple de pages (n-1, n)#
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")#
#
# Ici, chaque page n se transforme en couple de pages (n, n+1)#
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")#
#
# On réunit ces deux listes d'arêtes#
tab0 <- rbind(tab1, tab2)#
#
# On supprime les doublons créés par un nom sur des pages consécutives#
tab0 <- tab0[!duplicated(tab0),]#
#
# On crée le graphe, qui est déjà biparti#
g0 <- graph.edgelist(tab0, directed = FALSE)#
#
# Ceci est nécessaire pour pouvoir faire la projection et #
# obtenir le réseau de personnages (deux persos sont connectés #
# s'ils apparaissent sur les mêmes couples de pages)#
V(g0)$type <- bipartite.mapping(g0)$type#
#
# Voilà la projection…#
g <- bipartite.projection(g0)$proj1#
#
# Et voilà le produit final !#
g <- g - E(g)[E(g)$weight < 3]#
#############
### PLOT ####
#############
#
# Facilitons-nous la vie dans l'urgence de la conférence : #
# nous n'allons dessiner que la composante géante#
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))#
#
# Ici on crée le fichier où va arriver le visuel#
# On lui donne les dimensions qu'on veut#
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts#
# Et qu'on ferme à la fin avec la fonction dev.off()#
pdf("exemple.pdf", height = 15, width = 15)#
#
# À ce stade et pour mémoire, le tunnel est ouvert#
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge #
# et que le graphe doit prendre toute la place#
par(mar=c(0,0,0,0))#
#
# Là on dessine le graphe, avec plein d'ajustements…#
# Pour plus de renseignements, taper dans la console la commande suivant :#
# ?igraph.plotting#
plot(g,#
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),#
		vertex.size = log2(degree(g))-1,#
		vertex.color = "black",#
		vertex.label.color = "black",#
		vertex.label.dist = (log2(degree(g))-.2)/20,#
		vertex.label.family = "sans", #
		edge.width = log2(E(g)$weight) / 10,#
		edge.color = "darkgrey",#
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)#
	)#
#
# Et on ferme le tunnel#
dev.off()#
#
# Le résultat est assez illisible, et devra être amélioré au cas par cas#
# par exemple avec tkplot pour choisir un meilleur emplacement pour les noeuds#
# ou alors en changeant tailles, couleurs, etc.#
#
# À étudier : les différentes possibilités d'export en D3…
