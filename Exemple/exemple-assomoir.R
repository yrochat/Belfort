# TODO 
# -attributs S, T, P, ?
# -création d'une fonction

rm(list=ls())

# Ici on charge le package igraph qui sert à faire de l'analyse de réseaux
# si ça ne fonctionne pas, il faut d'abord le télécharger. Pour ça :
# install.packages("igraph")
library(igraph) 

# Ici on définit l'espace de travail. MODIFIER-LE pour que cela corresponde 
# à l'emplacement sur votre propre ordinateur
setwd("~/Documents/Belfort/Exemple")

#################
### LE RÉSEAU ###
#################

# On importe le csv sous forme de matrice d'incidence
mat <- read.table("assomoir-adj.csv", header = TRUE, check.names = FALSE, sep=",")

# On donne comme noms de ligne les noms de la première colonne
rownames(mat) <- mat[,1]

# Puis on la supprime
mat <- mat[,-1]
# Maintenant la matrice n'est plus composée que de 0 et de 1

# On crée un graphe biparti à partir de cette matrice d'incidence
g0 <- graph.incidence(mat, multiple = TRUE)

# On extrait la liste des arêtes, et on la copie deux fois
tab <- get.edgelist(g0)
tab2 <- tab1 <- tab

# Ici, chaque page n se transforme en couple de pages (n-1, n)
tab1[,2] <- paste(as.numeric(tab[,2])-1, tab[,2], sep="")

# Ici, chaque page n se transforme en couple de pages (n, n+1)
tab2[,2] <- paste(tab[,2], as.numeric(tab[,2])+1, sep="")

# On réunit ces deux listes d'arêtes
tab0 <- rbind(tab1, tab2)

# On supprime les doublons créés par un nom sur des pages consécutives
tab0 <- tab0[!duplicated(tab0),]

# On crée le graphe, qui est déjà biparti
g0 <- graph.edgelist(tab0, directed = FALSE)

# Ceci est nécessaire pour pouvoir faire la projection et 
# obtenir le réseau de personnages (deux persos sont connectés 
# s'ils apparaissent sur les mêmes couples de pages)
V(g0)$type <- bipartite.mapping(g0)$type

# Voilà la projection…
g <- bipartite.projection(g0)$proj1

# On simule (pour l'instant) un attribut en facteur pour chaque personnage, par exemple "homme", "femme", "groupe"
# TODO Je dois encore implémenter cette partie. Ce devra correspondre à Sciences, Techniques, Politique, etc.
# Et l'étudiant introduira un fichier avec les attributs
# À noter que les sommets apparaissent dans le même ordre que dans la matrice
identif <- factor(sample(c("S", "T", "P"), size = nrow(mat), replace = TRUE))
V(g)$identif <- identif

# Et voilà le produit final !
# À noter que le choix d'un seuil égal à 3 peut être modifié
# Un nombre (entier) plus bas permettra d'inclure plus d'arêtes
# Un nombre (entier) plus grand permettra d'inclure moins d'arêtes
g <- g - E(g)[E(g)$weight < 3]

############
### PLOT ###
############

# Facilitons-nous la vie dans l'urgence de la conférence : 
# nous n'allons dessiner que la composante géante
g <- induced.subgraph(g, vids = which(clusters(g)$membership == which.max(clusters(g)$csize)))

# Ici on crée le fichier où va arriver le visuel
# On lui donne les dimensions qu'on veut
# Cela crée une sorte de tunnel qui enregistrera tous nos ajouts
# Et qu'on ferme à la fin avec la fonction dev.off()
pdf("exemple.pdf", height = 15, width = 15)

# À ce stade et pour mémoire, le tunnel est ouvert
# Ce qu'on fait ici est de dire qu'il n'y a aucune marge 
# et que le graphe doit prendre toute la place
par(mar=c(0,0,0,0))

# Là on dessine le graphe, avec plein d'ajustements…
# Pour plus de renseignements, taper dans la console la commande suivant :
# ?igraph.plotting
plot(g,
		vertex.label = paste(substr(V(g)$name, 1, 6), ".", sep=""),
		vertex.size = log2(degree(g))-1,
		vertex.color = rainbow(length(unique(identif)))[V(g)$identif],
		vertex.label.color = "black",
		vertex.label.dist = (log2(degree(g))-.2)/20,
		vertex.label.family = "sans", 
		edge.width = log2(E(g)$weight) / 10,
		edge.color = "darkgrey",
		layout = layout.fruchterman.reingold(g, repulserad = vcount(g)^3.5)
	)
	
legend("topright", legend = levels(identif), pch = 21, col = "black", pt.bg = rainbow(length(unique(identif))), cex = 3)

# Et on ferme le tunnel
dev.off()

# Le résultat est assez illisible, et devra être amélioré au cas par cas
# par exemple avec tkplot pour choisir un meilleur emplacement pour les noeuds
# ou alors en changeant tailles, couleurs, etc.

# À étudier : les différentes possibilités d'export en D3…







